o. write more tests
   ... need to test for more edge cases in plotonscreen
       ... what happens when we try to plot something of the same width
       ... what happens when gap filling tries to plot something with the same width as what's there
           ... there's some resolution loss there; the perspectivetable table has 128 entries but line widths in it only does up to 19
               XXX could improve the resolution if we had duplicate entries in pf*lookup and used all five bits (up to 31) 
       ... what happens when we try to draw another line in the same platform on top of lastline

x. instead of drawing fat lines for each platform line, find the starting and ending scanlines of the visible portion of a platform and then
   interpolate between them
   ... XXX starts of platforms behind us will be rendered; have to take care in plotonscreen not to draw outside of the framebuffer!
       ... ugh, do not want to deal with that... they can't be behind us.  can't do neg deltaz.  have to render in perspective.
           ... so we have to clip the line.
               ... let's maybe revisit this later.
                   ... addressed this by having _arctan clamp deltay = deltaz and deltaz = 0 cases to the very top or bottom of the screen

x. write a large scale test that calls platlevelclear
   ... some of all of the three test platforms are drawn
   ... they're drawn starting and ending on the display where they're supposed to be

x. bug: why won't it render the one platform when there is only one platform in the level?
   ... is it rendering all of the platforms right now?  haven't taken a close look at this
   ... this antique bug probably went away by way of other changes
       ... yup

x. I think the arctan Y=0 logic isn't working; platforms disappear entirely when they're dead center in middle of the screen
   ... 02_arctan.pl thinks its working
       ... still, wouldn't hurt to have more tests to make sure it actually gets rendered

o. XXX plotonscreen *might* run into a spot of bother when arctan stuffs scanline to 0, and then 0 gets stored as lastline, so then it doesn't there to be a lastline
   ... actually, that should be okay
       ... after stuffing scanline to 0 or viewsize-1, plotonscreen shouldn't be called again
       ... a lastline of 0 will just cause it to not try to do any gap filling, which is fine

... rendering in 72 cpu cycles now

x. unit test cycle counts
   ... unit tests to make sure we plot a platform or two within a fixed number of cycles so we know if we accidentally make it really slow again
       ... done; tracking cycle counts in the commit messages
   ... get 04_runtime.pl going with per-instruction (typical) cycle counts 
       ... done

x. with the revised deltaz loop control (allowing deltaz=0 and deltaz = deltay), when deltay=deltaz=0, it'll keep rendering that platform over and over
   ... platrenderline checks ( deltay <= deltaz ) work fine with deltaz = deltay = 0
   ... .platlinedelta stuffing works; Y is positive so scanline gets stuffed as #0
       ... in .platlinedelta, maybe we need to first stuff case of the deltay = 0 before we look at other stuffed cases
           ... yup
    ... make sure we aren't rendering with deltay > deltaz again
        ... working on that in 05_times2.pl
           ... yup

# supposedly, there are 5320 machine cycles total available during vblank and overscan
10444 down from 10554 down from 10729
10744 down from 10898 down from 11216
5780 down from 5835 down from 5956
9878 down from 10163 up from 9988
6262 down from 7499 up from 6526

x. we can't ever actually get on a platform; there's always a gap of sky/background below it
   ... for one, we do need to render one chunk of the platform that's behind the player if only so that we can gap fill to it; ugh, that's gunna be ugly
   ... arctangent needs to start with z=0 I guess
       ... looks like we lose noticible precision that way; not sure
   ... hard-code checks for when deltaz = 0 in plotonscreen to automatically clamp the line to the very top or bottom?
       ... but not in plotonscreen; it doesn't take deltax/y; arctangent does
       ... add a special path that skips _arctan and goes straight to plotonscreen when deltaz = 0
           ... platrenderline does a jmp platnext if deltay > deltaz check
           ... platnextline does jmp platnext if deltaz - 2 < 0 check
           ... ugh, we know where to plot the platform bit (very top or bottom), but we don't know how wide to make it
               ... need a hypot with z=0
                   ... another small table perhaps, just of those?
           ... also, _plotonscreen is a lot to inline, and it's only a macro right now
               ... no problem, just branch back to it and treat deltaz=0 as one last go and deltaz<0 as done condition
           ... we want to skip arctan but maybe not plathypot; distance away tells us fatness of line to draw
    ... it might be easier to rig plotonscreen to clamp the line one way or the other if deltaz=deltay... or insert logic before the call to it 
        ... and save the extra _plathypot macro call
        ... we still want to stop looping when deltay > deltaz so we don't waste CPU
        ... yup, works

x. plotonscreen is kind of fucked; little changes (and new features) radically change what gets drawn when they're enabled/disabled
   ... but unit tests aren't picking up on any differences in what gets plotted when branching to plotonscreen3a or plotonscreen8 is enabled when drawing to lastline
   ... differences in what gets rendered seems to have been in the past largely influenced by run time and it running out of time to render things
       ... things should be much better in that regard now so I'm not sure what's up

x. use unit tests to figure out how long rendering takes in different circumstances.

o. get some banding going for sky / horizon
   ... go into rarified air where it starts to get black and spacey at high levels
   ... maybe greenish ground instead of brown
   ... need to move padding to the top too to balance it out
   ... add the players Y position to the 'background' table index
   ... need to cap off players Y height otherwise the platforms start repeating and we run out of background material

o. observed deltaz=0 while debugging shorter lines overwriting wider ones; maybe that's the problem?  if not, have to reproduce this view angle
   ... playerz=0, playery=$23, 
   ... this is likely gone now, fixed in dfab7f

x. shouldn't be calling arctan with 0s for deltas since part of the formula the table is generated with is atan($z/$y)
   ... calling it with two 0 deltas will make it run forever; okay, it handles this special case now, though I wish I didn't have to spend the CPU cycles
       ... swapping Y and Z could avoid a division by zero if we stop following the platform when deltaz == 1, which we currently do
   ... the way the table is computed and used now, Z will always be >= 1 and Y no longer needs a special case as the table handles it correctly
   
x. make the arctan table two pages long instead of one for more precision?
   ... skipping this one as the 256 byte utilization instead of 128 byte seems pretty good

x. write tests 
   ... z-buffering -- drawing over stuff and failing to draw behind stuff
   ... lastline being updated or not updated as appropriate
   ... gap filling with correct color
$cpu->set_pc($symbols->platlevelclear);
$cpu->write_8( $symbols->deltaz, 10 );
$cpu->write_8( $symbols->deltay, 2 );
$cpu->write_8( $symbols->INTIM, 0x10 );  # stuff a value in the timer output so platform rendering doesn't think its out of time

x. readstick isn't currently keeping Y from going below 0 and that trashes things as soon as it goes below 0
    ... kinda in the process of reworking readstick and gamelogic
    ... playery higher than $2c or so also keeps it from redrawing even if we go back down
        ... huh, jsr'ing to platlevelclear instead of platresume in the first of three calls makes it able to recover
    ... readstick now limits Y, and some serious bug thrashing seems to have cleared up the redraw and garbage problems

x. the thing is currently rendering a lot of width 0 stuff; this gets drawn as nothing on the display; this is probably a fuck-up with the arctan lookup
   operating without bounding
   ... actually, the test was bunk; was testing the zero bit to test if A was zero, but it didn't match, so stats were off; actually doing no zero width platforms

x. testing making no calls to platresume and that seems to be working pretty well; maybe I should do an experiment and have it count how many lines it does
    ... $0e or so.  not many.  okay, $14 with the first jsr platresume after the jsr platlevelclear enabled.  same ($14) with the 3rd platresume enabled.
    ... after add gap filling logic to plotonscreen to replace the fatlines logic, it is drawing fewer platforms but says $1C lines considered (28);
        it's also drawing everything forward of our position so many of those probably aren't visible

x. observing a lot of garbage being drawn that isn't platform
   ... aha, curplat is going way past 08; not detecting the end of level0 properly
       ... break on platnext0
       ... okay, it's fine until we return and platresume is called again
   ... fixed; on resume, check to see if we're off the end of level0

x. hey, wait... deltaz is apparently counting down to 1 for all platflorms, not just the ones we're standing on
   ...    dec deltaz              ; deltaz goes down to zero; ... not always!  only when it isn't off in the distance!
   ... how does this look right at all?
   ... platfound initializes deltaz with level0+1,y - playerz
   ... changed it to count down to level0+0,y - playerz and stop
       ... hey, the platforms got a lot shorter.  I guess it really was just drawing them until it ran out of CPU!
       ... so that's where all of the CPU was going!  it really looked right, too.  huh.  crazy.
       ... okay, now it's really, really fast; it creams through the three platforms during the first call and finishes with lots of time left on the clock

x. egads, how many times do we draw a bit platform over a bit of the same platform?
   ... interpolating between start/end is starting to look more and more appealing
   ... $15 times; not terrible; still...
; how often do we draw a bit of platform over a bit of platform of the same color?
        lda view,x
        and #%1110000
        ldy curplat
        cmp level0+3,y
        bne testytest
        inc num0
testytest 

x. I think I have z-buffering hooked up backwards!  low numbers are far away
   ... well, flipping the sense of it makes it draw nothing on the plain background, and tracing it, it does the right thing in the case of the plain background
   ... correct in the case of 8 being in the frame buffer and it wanting to draw a 9 there

x. reconsider trying to enforce a 45 degree viewing angle; we're rendering up to $1E platform lines and can't stuff the green platform off in the distance any more
   ... done; this speeds things up a lot

x. remember the last scan line we drew a line on so we can fill in the gaps when we draw the next line.
    ... need to handle the case where lastline-curline is +/- 1 and not recurse so we don't clobber a narrower line with a fatter line... okay
    ... after this, we had to bump up our INTIM check from 7 to 9 (128 more cycles) to avoid screen jump; we're rending up to $1C lines but we can't see
        the far away green platform at the start any more
        ... also, closer things aren't being rendered when they should
    ... could at least shave some cycles from plotonscreen so we can put INTIM back down to 8 at least
    ... upwards of $29 gap lines are filed in (or depth checked to see if they can be filled in); this is waaay too many
        ... is there a black platform...?
        ... even skipping the terrible zero width platform pieces, I'm seeing $28 bits of gap filled in though the green platform bit starts to show up again

x. with some inc num0 logic, I'm not finding any cases where 255/out of range stuff is being returned from arctan; dropping the error checking

x. really not convinced we're getting 111 lines of display; is the 45 degree angle check to blame?  what is the real range of the hypot table?
   ... go through this rendering logic again
   ... angle = atan(y_delta/z_delta)... delta_z must be greater than (>) delta_y or it's out of our 45 degree range
       ... yeah, that 45 degree check, or some related logic, was screwing us up there; still want to go through all of the rendering math and check things
   ... okay, we were *not* getting 110 lines of display; the arctan table has to be generated for the lines since it returns the scan line number

x. get rid of marksweep in favor of just blanking at the start of the frame and redrawing

x.         jmp platnext            ; XX experimental -- on the same level as the platform?  don't show it.  sucks that our arctan table doesn't have any 0s in it so this case can be handled correctly, but maybe that can be tweaked.
         ^--- fix this somehow; maybe treat the platform as if it is 1 lower than us while we're exactly on it

x. lda playerzspeed        ; this is 1.4.3 fixed place
    ^--- make not 1.4.3 and I don't think it is anyway

x. rename plattryline to platrenderline since that's where the rendering happens

x. curline and deltaz are probably redundant with each other as well and one could be eliminated
   ... probably eliminate curline since a lot of routines use deltaz directly and its more immediately useful

x. get rid of the platstart variable
   ... we can get rid of platstart if we skip the optimization where we figure out which line of the platform is the first one we can see
       ... I don't think this will hurt us too much
       ... then we'll just be working from level0,1 backwards to level0,0
   ... curline starts at level0,1 and goes towards level0,0
   ... we stop using tmp1 which was platend, which was actually the platstart, which is level0,0
   ... okay, now curline just moves straight from level0,1 to level0,0

x. try to get rid of curlinewidth?
   ... easily done; saved once, loaded once, with no tmp destructive routines in between
   ... oops, mostly did this with abusing the S register but didn't quite finish it; trying to take it out entirely made things glitch
   ... okay, except for the fatlines logic that's commented out, this is done

x. get rid of all of these jsrs to save memory

x. rework so that the level0 data structure includes platstart and platend rather than platstart and platlength; simplifies logic/temp usage a bit

x. try to get rid of deltayneg and instead do 2's compliment like god intended?
   ... playery - platform height ... > 0 = platform is below us, < 0 = platform is above us
   ... previously, if the platform was higher than the player, we redid the math and did platform height - playery
   ... routines using deltay
       ... arctan
       ... plathypot
       ... platlineseek, to figure out if a line is as far ahead of us as it is above/below us to compute a 45 degree viewing angle
       ... fatlines

x. in platnext:
; this leaves this uninitialized; don't do this
;        lda INTIM
        ; cmp #8
;       cmp #9
;       bpl platnext0
;       jmp vblanktimerendalmost    ; not enough time left to start another platform
        jmp platnext0

.. in platlevelclear:          sty curplat             ; XXX don't reset to 0; create a variable for current platform player is on and use that instead
   ... not sure about that.  don't want to create a new variable, and skipping past stuff we can't see should be pretty quick or we can make it quicker.

x. try to get rid of curlineoffset?
   ... plathypot is called right after it is computed, and that uses tmp1 and tmp2
       ... keep in the stack pointer register?
           ... yup, totally worked

x.         iny                     ; move to the platform length <-- this is silly
    do this instead:   lda level0+1,y

x. platlinedelta can be in-lined; only used one place
   ... did it with a macro

x. attempts to make deltaz an alias to tmp1 have failed; not sure why that won't work; a lot of these vars look like they can be cut down
   aha... plathypot makes heavy use of deltaz, deltay, tmp1 and tmp2; mucking that all up

x. platresume is called from three places; are we over-running the timer in any of them?
    when the time is less than $30 ($30 * 64 CPU cycles), we stop doing lines
    $11, $b5
    $16
    $00, $16, $90 (probably an overflow), $b9 (probably an overflow; called from where #$2a = 42 is stuck in TIM64T)
    $12 when TIM64T is loaded with $5F
    $14 when TIM64T is loaded with $22 ($22 is less than platresume_timer_ticks_need, which is $30)
    $B5 when TIM64T is loaded with $2A ($2A is less than platresume_timer_ticks_need)
    $06 when TIM64T is loaded with $5F
    $14 when loaded with $22
    $B5 when loaded with $2A (probably overflowed) ... watch it overflow?
    $11 when loaded with $5F
    ... okay, loaded with #$22, tracing...
        ... $20 ticks left on the timer by the time we hit platfound
        ... it does a line before checking what's left in the timer
        ... $1F at platlineseek
        ... $1E at platlinedelta
        ... $1D at plathypot
        ... $1C at plotonscreen
        ... $1B at platnextline
        ... fatlines
        ... oops, by platnextline a few times as the thing continues to wind down; platnextline is where INTIM is checked and compared to hard-coded #6
        ... platnext also compares INTIM to #8
        ... platlevelclear compares INTIM to platresume_timer_ticks_need which is currently 48 (!!)
        ... so it looks like maybe we can only check in platnextline and be okay
            ... nope
            ... still, platresume_timer_ticks_need is stupid.  that's the time we think it takes to render all platforms.  doesn't fit with large/varied levels.
    ... okay, got rid of platresume_timer_ticks_need and it now only exits at platnext or platnextline on very small remaining timer values. 
        ... platresume_timer_ticks_need was really only useful because it kept it from marksweeping and restarting when it didn't have time to finish
            ... and that avoided flicker from doing multiple restarts and marksweeps in the same frame with the second not finishing
    ... had to rework; marksweep is called once at the end of the frame rather than every time it hits the end of the level; that works right now but isn't 100%;
        ... if it takes more than two frames to draw the screen, stuff will be prematured deleted
        ... marksweep should only be done at the end of the frame if the thing has since rendered all of the platforms start to end
        ... vblanktimerendalmost counts how many loops it has to do before the timer runs down to zero; with the hard coded values plugged in now, it's between 9-24

x. why the hell do we jsr gamelogic in platlevelclear2?
  ... apparently just because that's the point where it's kind of done with things in there
  ... fixed

x. in platrumes, don't iterate until the end of all of the platforms but instead do a fixed number of platforms or work for a fixed number of frames
   ... to better accomodate large levels and wrap-around
   ... maybe no wrap-around for a platformer
   ... okay, it only goes to the end now and doesn't attempt to restart until explicitly told to

x. marksweep should only be done at the end of the frame if the thing has since rendered all of the platforms start to end
   ... otherwise, if it takes more than two frames to draw all of the platforms, stuff will be premature deleted
   ... or else just clamp down how much data we render (eg, only 100 lines of data) and then stop and call it good; yeah, even better
       ... looks like we have *plenty* of time right now to redraw platforms completely for the frame
           ... but the platform draw logic should also draw enemies
       ... getting rid of mark sweep would free up that bit
           ... that bit could potentially be useful for marking up sprite data

old comments:
; after finding the first platform, seeking, and one divide, INTIM reads #$23 (35).  starts at #$2B (43).
; update: after doing the first platform's first line with the z/y atan table, INTIM reads #$27.  better.
; 76 cycles per line, 37 vblank lines, for a meager 2812 cycles

done:
; todo: add clause for ignoring platforms *too* far away, or else let CPU be the limiting factor
... cpu is the limiting factor

; done: figure out how many frames it takes to draw in a screen, then every that many frames, actually read control and blank the screen

; done: count generations (vblanks) and don't redraw everything more than once...

; idea: store a "display list" type thing with instructions:  how many lines to repeat the same thing;
; then color to change, width to change to, and width delta (+/- width with a small fractal part) each line.
; this would allow double buffering, quicker rendering of the platforms (bresenham), etc.  since there's only
; about three platforms on the screen right now, this would be a very short list.

; idea:  joust...?  left/right turns you around, forward makes you run on a platform, button flaps, of course
; or no turn-around initially, since that would require rendering the level from the opposite perspective

v/ we stop filling gaps when we start running low on CPU.  is there a better way to handle this?
   ... fill gaps faster and don't even attempt to draw a line of a platform unless there's lots of time left on the clock
       ... not perfect

.............

toggle debugger mode in stella is `
enter options menu mode is TAB
enter ROM launcher is escape
quit is control-q

......

76 (228/3) CPU clock cycles per scan line
3 lines of vsync, 37 lines of vblank, 30 lines of overscan = 70 lines * 76 CPU cycles = 5,320 game logic cycles
in this order: vertical sync, 192 lines of actual picture, then overscan
there are 22.6 cpu cycles each line after hsync and before the actual picture area

..........

there are viewsize lines (currently 101)
102 is score display setup
103-111 in score display itself
112 in score display teardown

................

o. 3D glasses support; use alternating sets of pf*lookup tables for left and right eyes

o. the plotonscreen rule where it skips drawing if the new line is in the same position as lastline isn't great when deltay = 0
   ... the platform is drawn only at its shortest point, not the nearer widest
       ... ignoring this as that's only a moment of the animation and the next and previous frames will look okay
           ... and if you see if the leading edge of the platform on deltay = 0, then you're not going to land on it anyway

; todo next: sprites.  nice thing about first person is we don't need to draw ourselves!  so we can realistically have
; two enemy birds flying around.  enemy birds are going need x, y, and at least one velocity.
; clipping will be a bitch!
; near/in gamelogic, make the enemy bird fly
; compute distance with the current deltay, deltaz vars and arctan table
; peek into the framebuffer and see if there is something nearer than them
; modify the inner loop to show a damn sprite or two... vary the colors, width, and graphics... good luck!

; todo: game logic is very rough. besides floating down, we also seem to float back to the start of the level!

; todo: give the player a point every time they kill a bird!

; todo: waves.  when the birds are dead, pause a moment, and create more!

o. DCP Plus demo shows how to use the Pitfall 2 custom hardware (supported by Stella, Harmony, and Melody) which has fast fetchers and overrides lda #xx! awesome!
    o. too bad it doesn't override sta instead =P

o. replace this code for disabling sprites with something that shows a sprite or two:
        sta PF0
        sta PF1
        sta PF2
        lda #%00001110
        sta COLUPF
    ... should be easy to decide whether to hide/show a scanline of player data; compare the Z position of the player to the width (distance) of the platform piece

o. re-working the vblank logic, I broke joystick button latching (which is part of the vblank enable register)
   ... need to re-read how this is supposed to work
   ... okay, writing a 1 to D6 of VBLANK enables latching; once enabled (or reset by turning off then on), INPT4 and 5 are high but go low and stay low on fire

o. physics is kinda fucked; revisit
   ... playeryspeed is not handled comprehensively
   ... handle as 2s compliment
   ... check carry/zero in gamelogic to enforce floor/ceiling

o. bcs gamelogic2      ; don't write back to playerz if this addition would take it above $ff XXXX actually, wouldn't this be the win condition for the level?

o. beq gamelogic4      ; don't write back to playery if this subtraction would take it to zero; XXX actually, wouldn't this be the death condition?

o. the TIM32 timings are quite probably off by one or so
   ... vblank, vsync early/late, etc

o. our imaginary dude should have some height; rather than a platform at the same height as us being shown at eye level, it should be offset downwards

o. _plathypot could probably be optimized

o. let's turn this into a sort of freerunning first person platformer
   ... Integral Trees-ish?
   ... very low gravity
   ... lots of stuff to jump off of
   ... springy stuff too!
   ... try to maintain altitude
   ... omg!  vines to swing on, pitfall style?
   ... "Sky Castles" ... sky castle theme... use a sprite to render off in the distance castleage
   ... sometimes the user can flap a bit (mario style get a run for it and fly for a while), sometimes for a limited time they can fly around, sometimes only jump
       ... some kinds of power ups or something; changing bodies?
   ... philosophy:  create a machine that's fun to play with
   ... would be fun to have things occasionally falling from the sky
   ... lob things on an arc to hit switches of some sort to raise grates and divert water?
   ... bouncing big ball things kicking around?
   ... shoot arrows to flip switches and kill knights?
   ... platforms that move around?

o. maybe rather than the platforms being solid colored, make them striped as in Atari 2600 - Demoscene - 02 - Ataventure - Atari 2600 demo by Kk Dma.mp4
   ... could use the specified platform color when drawing the main lines and then fill gaps with another (black? level0+5,y?)
   ... also Atari 2600 - Demoscene - 04 - Trsi Digital Sounds System Crest - aTaRSI (2013) Atari Vcs.mp4 shades things darker when they're further away -- nice!
   ... the background should also be shaded and colored
       ... probably as a function of playery

o. shade platforms darker when they're further away
   ... drop off to darkness should be logarithmic
       ... good thing we already have a lookup table
   ... platforms with different colors on the top and bottom?
   ... key platform pf bitmap graphics off of color plus width (use the whole scanline value) to draw different shape platforms
       ... such as round things
       ... yup, bitmaps for the platforms

o. need to cap the player's Y 

o. maybe make the ground greenish rather than brownish
   ... or maybe we're above water

o. plotonscreen would let us draw veritcal bars such as tree trunks
   ... leafy vines
   ... metal grates
   ... brick walls
   ... waterfalls

o. need to get sprite rendering going too
   ... we have 14 cycles free right now.  
   ... if that isn't enough to pull sprite data from the frame buffer, then at least it should be enough to:
         lda (spritedata_pointer),y ; 5 cycles
         sta GRP0					; 3 cycles
       ... low byte of the zero page spritedata_pointer would have to be modified during vblank rendering to position the sprite
       ... would use 200 or so bytes of data for the sprite rather than enabling/disabling it; that makes animation prohibitive
   ... would be to cool to, if the 0 bit (eg) is clear, then instead of doing platform rendering, do sprite rendering using the other 7 bits of data!
       ... existing platform/background data could just repeat for that line
       ... sprite data would be explicitly turned off and explicitly updated but otherwise itself would just repeat
           ... that would make for tall, skinny, stretched out sprites

o. make the top 1/3rd and bottom 1/3rd of the screen have 2 scan line resolution while the middle still has one
   ... warp the arctangent table
   ... run two different kernels
   ... this would help a lot with gap filling to the edges of the screen which is currently eating up obscene numbers of cycles

o. really need to lock it down to an odd number of scanlines; otherwise, we can't +/- any number in arctangent without walking one off the end when adding
   ... currently at an odd number

o. according to stella, we're on scanline 15 already by the time we start rendering the screen

o. steal physics from flapping.20050207.asm?

o. land on platforms, bounce off of platforms when going up.
   ... the flap and gravity routines need to look through the list of platforms (ugh)
   ... no, we just need to remember the position of the platform we're above/below
   ... for the sake of rendering things, deltaz and deltay are relative to our eyes; our feet are probably lower down
   ... deltay > 0 means the platform is above us
       ... it's playery - platformy; if positive, the platform is below us
   ... while rendering, set bits when different conditions come up
       ... deltaz = 1 and deltay = -1 means we've run face first into a platform, maybe
       ... deltaz = 0 and deltay = 1 means we're standing on something

o. gap filling won't fill to exactly the bottom line
        lda lastline            ; make sure that there is a lastline and don't try to fill gaps if not
        beq .plotonscreen8      ; skip gap filling if there is no lastline
   ... okay, fixed that by stuff $ff in instead, but the first line is glitchy now

ROM bytes used up to  $fa0e ... that's almost 2/3rds full

o. monitor ranoutoftime (break ranoutoftime) to make sure we're allowing enough time for plotonscreen to run
    ... turning off gap filling isn't an entirely bad effect
    ... scanlines.txt has scanline counting methods

o. rather than trying to leave and re-enter, do VSYNC/VBLANK diddling inline in plotonscreen
    ... use a byte to keep track of where we are in the vblank process
    ... when the timer hits 0 exactly, WSYNC and update registers
    ... make this timer check a macro and use it from enough places that the timer never expires
    ... okay, checking every 64 cycles would be too much overhead.  we're better off checking less often and then burning some time.

$cpu->write_8( $symbols->platnextline0a+1, 16 ); directly determines whether shit gets fucked up or not.  huh.  how!?
    ... aha.  needs *21* on the clock to always be safe.  otherwise, there may or may not be enough time left.
    ... my guess is that it goes negative and beyond and the ranoutoftime check doesn't work properly so it keeps trying to do more lines
        ... output curplat, deltaz, lastline
        ... yup, correct.  it continues on from deltaz=2 to deltaz=1
    XXX okay, we need to make timer expiring logic more intelligent, one way or another
        ... if there's a lastline, make sure that abs(curline-lastline) > INTIM before we continue
do at 779 a version of what we do at 787
        ... or else invert control like we were thinking of before



